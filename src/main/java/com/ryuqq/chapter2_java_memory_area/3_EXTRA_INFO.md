# 공부하다 궁금한 것들

## 왜 최대 힙 크기와 스택 메모리를 줄이는 게 더 많은 스레드를 만들 수 있는 유일한 방법인지?

### 1. JVM 메모리 구조와 제한
JVM은 다음과 같은 메모리 영역을 포함합니다:
- **힙(Heap)**: 객체와 배열이 저장되는 메모리.
- **메서드 영역(Method Area)**: 클래스 메타데이터와 상수 저장.
- **스택(Stack)**: 각 스레드가 사용하는 메모리로, 메서드 호출 정보(지역 변수, 매개변수, 리턴 주소 등)를 저장.

### 메모리 경쟁
- **스택 메모리**: JVM은 각 스레드마다 독립적인 스택 메모리를 할당합니다.
- **힙 메모리**: 모든 스레드가 공유하는 메모리로 객체를 저장합니다.
- **운영 체제는 JVM에 사용할 수 있는 메모리를 제한**하며, JVM은 이 메모리를 힙, 메서드 영역, 각 스레드의 스택으로 나눕니다.

---

### 2. 스레드 생성 시 스택 메모리 사용
스레드 생성 시, 운영 체제는 각 스레드에 대해 **스택 메모리 크기를 미리 할당**합니다.
- 스택 크기가 크면:
    - 스레드당 많은 메모리가 필요합니다.
    - 전체 메모리에서 적은 수의 스레드만 생성할 수 있습니다.
- 스택 크기가 작으면:
    - 스레드당 메모리 사용량이 줄어들어, 더 많은 스레드를 생성할 수 있습니다.

---

### 3. 힙 메모리와의 관계
- JVM 힙 메모리는 모든 스레드가 공유하므로, 힙 크기가 크면 전체 메모리에서 스택 메모리에 할당할 공간이 줄어듭니다.
- 반대로, 힙 크기를 줄이면 스택 메모리에 사용할 수 있는 공간이 늘어나 더 많은 스레드를 생성할 수 있습니다.

---

### 4. 왜 힙과 스택을 줄이는 것이 유일한 방법인가?
#### 스레드 수 제한의 원인
1. **메모리 한계**: 운영 체제가 JVM에 제공하는 메모리 양은 고정되어 있습니다.
2. **스택 메모리 요구량**: 각 스레드가 고정된 크기의 스택 메모리를 필요로 합니다.

#### 다른 선택지가 없는 이유
- **운영 체제의 메모리 제한**: JVM이 사용할 수 있는 메모리 양을 늘릴 수 없으면, 스택과 힙의 크기를 조정하는 것이 유일한 옵션입니다.
- **스택 메모리 고정**: 스레드 생성 시 스택 메모리는 고정 크기로 할당되므로, 크기를 줄이지 않으면 메모리가 부족해 더 많은 스레드를 생성할 수 없습니다.
- **힙 메모리와 스레드 경쟁**: 힙 메모리와 스택 메모리는 같은 프로세스 내에서 경쟁하므로, 힙 크기를 줄이지 않으면 스택 공간을 확보할 수 없습니다.

---

### 5. 결론
스레드를 더 많이 생성하려면:
1. **스택 크기를 줄인다**:
    - 스레드당 필요한 메모리 양을 줄여, 더 많은 스레드를 생성할 수 있습니다.
2. **힙 크기를 줄인다**:
    - JVM 전체 메모리에서 스택 메모리에 사용할 수 있는 공간을 늘립니다.

---

### 코드 예제
```java
public class ThreadExperiment {
    public static void main(String[] args) {
        int count = 0;
        try {
            while (true) {
                new Thread(() -> {
                    try {
                        Thread.sleep(1000000); // 스레드 대기
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }).start();
                count++;
            }
        } catch (OutOfMemoryError e) {
            System.out.println("최대 스레드 수: " + count);
        }
    }
}

```
JVM 옵션 조정:

출력 예시:
```bash
java -Xmx128m -Xss256k ThreadExperiment
```


결과:
스택 크기를 줄이고 힙 크기를 줄이면 더 많은 스레드를 생성할 수 있습니다.
기본 설정(-Xss1m)에서는 약 2,000개의 스레드를 생성할 수 있다면, -Xss256k로 줄이면 약 8,000개의 스레드를 생성할 수 있습니다.

## 자바에서 문자 비교할 때 왜 `==`이 아닌 `equals()`를 사용하는가?

자바에서 문자열 비교를 할 때, **`==` 연산자** 대신 **`equals()` 메서드**를 사용하는 이유는 
문자열이 저장되는 **상수 풀(String Pool)**과 관련이 있습니다.
문자열 비교 시 두 연산자는 서로 다른 방식으로 동작하므로, 안전한 값을 비교하려면 `equals()`를 사용하는 것이 중요합니다.

---

### 1. `==`와 `equals()`의 차이

#### 1) `==` 연산자
- **`==`는 참조(reference)를 비교합니다.**
- 두 문자열 변수가 **같은 메모리 주소를 가리키는지** 확인합니다.
- 문자열이 **상수 풀에 저장되어 동일한 객체를 참조**하면 `true`를 반환하지만, 그렇지 않으면 `false`를 반환합니다.

#### 2) `equals()` 메서드
- **`equals()`는 문자열의 값(value)을 비교합니다.**
- 두 문자열의 내용이 동일하면 `true`를 반환합니다.
- 문자열이 상수 풀에 있든, 힙 메모리에 있든 상관없이 **문자열의 실제 값**만 비교합니다.

---

### 2. 문자열 상수 풀과 `==`의 동작

#### 1) 상수 풀에 저장된 문자열
- 문자열 리터럴(예: `"example"`)은 상수 풀에 저장됩니다.
- 동일한 문자열 리터럴은 상수 풀에서 **공유**됩니다.

```java
String s1 = "hello";
String s2 = "hello";

System.out.println(s1 == s2);      // true (같은 객체를 참조)
System.out.println(s1.equals(s2)); // true (값이 같음)
```
"hello"는 상수 풀에 저장되며, s1과 s2는 같은 객체를 참조합니다.
따라서 ==와 equals() 모두 true를 반환합니다.

#### 2) 새로운 객체 생성
new 키워드를 사용하면 힙 메모리에 새로운 문자열 객체가 생성됩니다.
이 경우, 동일한 문자열이라도 상수 풀에 있는 문자열과는 다른 객체입니다.

```java
String s1 = "hello";
String s2 = new String("hello");

System.out.println(s1 == s2);      // false (다른 객체를 참조)
System.out.println(s1.equals(s2)); // true (값이 같음)
```

### 3. 왜 equals()를 사용해야 할까?
#### 1)  상수 풀이 아닌 문자열 비교
   ==는 객체의 참조를 비교하므로, 동일한 문자열이라도 참조가 다르면 false를 반환합니다.
   문자열의 실제 값(value)을 비교하려면 항상 equals()를 사용해야 합니다.

```java

String s1 = "world";
String s2 = new String("world");

if (s1.equals(s2)) {
System.out.println("같은 문자열입니다."); // 이 방식이 안전
}

if (s1 == s2) {
System.out.println("같은 참조입니다."); // 이 경우 참조가 다르면 실행되지 않음
}
```

#### 2) intern() 메서드를 이용한 상수 풀 강제 사용
   문자열을 상수 풀에서 관리하고 싶다면, intern() 메서드를 사용합니다.
   intern()은 문자열을 상수 풀로 이동하거나, 이미 상수 풀에 있는 동일한 문자열을 반환합니다.

```java

String s1 = new String("hello");
String s2 = s1.intern(); // 상수 풀에 저장된 "hello" 반환
String s3 = "hello";

System.out.println(s2 == s3);     // true (같은 상수 풀 객체)
System.out.println(s1 == s3);     // false (s1은 힙 객체)
System.out.println(s1.equals(s3)); // true (값은 동일)
```

### 4 프로그래밍에서 안전성 확보
   문자열 비교에서 ==는 코드에 따라 예기치 못한 결과를 초래할 수 있습니다.
   equals()는 문자열 값에만 의존하기 때문에 값 비교의 안전성을 보장합니다.




### jvm 옵션 모음

- -Xmx, -Xms	힙 메모리 초기값, 최대값
- -Xss	스레드당 스택 크기
- -XX:+UseTLAB	TLAB 사용 여부
- -XX:+DoEscapeAnalysis	Escape 분석 사용
- -XX:MaxMetaspaceSize	Metaspace 최대 크기 지정

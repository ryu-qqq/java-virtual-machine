# JVM 런타임 스택 프레임 구조

## 1. 스택 프레임 개요
JVM에서 메서드가 호출될 때마다 새로운 **스택 프레임(Stack Frame)**이 생성되고, 메서드 실행이 끝나면 해당 프레임이 제거됩니다. 각 스택 프레임은 다음과 같은 주요 구성 요소를 가집니다.

## 2. 스택 프레임 구성 요소

### 1️⃣ 지역 변수 테이블 (Local Variable Table)
- 각 메서드에서 선언된 **지역 변수 및 매개변수(파라미터)**를 저장하는 공간
- 32비트(4바이트) 단위 슬롯으로 구성됨
- `long`, `double`은 64비트(8바이트)라서 슬롯 2개 차지
- **슬롯 재사용 가능** (불필요한 공간 낭비 방지)

#### 예제
```java
public void example(int a, int b) {
    int sum = a + b;
}
```
이 코드 실행 시 지역 변수 테이블:
```
[0] this (인스턴스 메서드일 경우)
[1] a
[2] b
[3] sum
```

### 2️⃣ 피연산자 스택 (Operand Stack)
- 바이트코드 명령어들이 연산을 수행하는 공간
- **피연산자를 push → 연산 수행 → 결과를 pop**
- JVM은 **레지스터 기반이 아니라 스택 기반 VM**

#### 예제
```java
int x = 3;
int y = 5;
int z = x + y;
```
이 코드의 바이트코드 실행 과정:
```
iconst_3      // 3을 피연산자 스택에 push
istore_1      // x = 3 (지역 변수 테이블 저장)

iconst_5      // 5을 피연산자 스택에 push
istore_2      // y = 5 (지역 변수 테이블 저장)

iload_1       // x(3) 피연산자 스택 push
iload_2       // y(5) 피연산자 스택 push
iadd          // x + y 수행 후 결과 push
istore_3      // z = 8 (지역 변수 테이블 저장)
```

### 3️⃣ 동적 링크 (Dynamic Linking)
- 실행 중 필요한 **메서드, 필드, 클래스 참조 정보**를 저장
- 상수 풀(Constant Pool)에서 메서드 참조를 가져옴
- 메서드 호출 시 해당 메서드의 실제 메모리 주소를 가져와 실행

#### 예제 (메서드 호출 흐름)
```java
public class Example {
    public void methodA() {
        methodB();
    }

    public void methodB() {
        System.out.println("Hello, JVM!");
    }
}
```
1. `methodA()` 실행 → 동적 링크에서 `methodB()`의 주소를 찾아 실행
2. `methodB()` 실행 후 종료되면 다시 `methodA()`로 복귀

### 4️⃣ 반환 주소 (Return Address)
- **메서드 실행이 끝난 후 돌아갈 위치(PC 레지스터 값)를 저장**
- 인터프리터 모드에서만 필요 (JIT 모드에서는 필요 없음)

#### 실행 흐름
```java
public void example() {
    int x = sum(3, 5);
}

public int sum(int a, int b) {
    return a + b;
}
```
1. `example()` 실행 → `sum()` 호출 (반환 주소 저장)
2. `sum()` 실행 후 결과 반환 → 저장된 반환 주소로 복귀

### 5️⃣ 기타 정보
- **예외 핸들링 정보 (Exception Table)** → try-catch 예외 처리 정보 저장
- **메서드의 접근 제한자 및 특성 정보** → synchronized 여부 등

---

## 3. JVM 실행 방식: 인터프리터 vs JIT 컴파일러

### 🔹 인터프리터 (Interpreter)
- **바이트코드를 한 줄씩 읽고 해석 → 실행**
- 빠르게 실행 시작 가능하지만, 반복 실행 시 성능 저하

### 🔹 JIT(Just-In-Time) 컴파일러
- 자주 실행되는 코드를 **네이티브 코드로 변환 후 캐싱**
- 이후 실행 속도가 비약적으로 향상됨

#### 실행 흐름
```
1. JVM 실행 → 인터프리터가 바이트코드 한 줄씩 실행
2. 특정 메서드가 여러 번 실행됨
3. JIT 컴파일러가 해당 메서드를 네이티브 코드로 변환
4. 이후부터 네이티브 코드 실행 → 성능 최적화
```

---

## 4. 64비트 타입 (long, double)이 원자적이지 않은 이유

### 문제: 64비트 데이터를 32비트 슬롯 두 개에 나눠 저장
- `long`, `double`은 **32비트 슬롯 2개 사용**
- 멀티스레드 환경에서 한 스레드가 `long` 읽는 도중, 다른 스레드가 값을 변경하면 데이터가 꼬일 수 있음 (**Tearing Issue**)

### 해결 방법
- **`volatile long x;` 사용** → JDK 1.5 이상에서 JVM이 한 번에 읽고 쓰도록 보장
- **AtomicLong, AtomicDouble 사용** → (java.util.concurrent.atomic 패키지)

---

## 5. JVM 실행 흐름 (전체 정리)

1️⃣ **메서드가 호출되면 → 스택 프레임 생성**
- 지역 변수 테이블에 변수 저장
- 피연산자 스택을 사용하여 연산 수행
- 동적 링크로 메서드 참조
- 반환 주소 저장

2️⃣ **인터프리터가 처음 실행하며 바이트코드를 한 줄씩 읽음**

3️⃣ **JIT 컴파일러가 자주 실행되는 코드를 네이티브 코드로 변환**
- 이후 실행 속도 🚀 향상

4️⃣ **메서드 실행이 끝나면 반환 주소로 복귀 (PC 레지스터 복원)**

---

## 🎯 JVM 런타임 스택 프레임 요약
✅ **반환 주소**는 **PC 레지스터와 연결**되어 실행 흐름을 관리
✅ **인터프리터 vs JIT** → JIT이 자주 실행되는 코드만 네이티브로 변환하여 속도 최적화
✅ **long, double이 원자적이지 않은 이유** → 지역 변수 테이블에서 슬롯 2개 사용으로 경합 발생 가능
✅ **슬롯 재사용** → 지역 변수 테이블의 공간을 절약하기 위해 필요 없는 슬롯을 다시 사용

---


# 🚀 JVM GC 최적화 개념 완벽 정리 (부제: GC를 조져보자)

## 💀 GC는 뭐하는 놈인가?
GC(Garbage Collector)는 **뒤진 객체(더 이상 참조되지 않는 객체)를 치우는 새끼**다. 그런데 살아 있는 새끼를 실수로 치우면? **좆됨(NullPointerException 터짐).** 그래서 GC는 먼저 **살아 있는 객체를 찾고, 참조가 끊긴 객체만 제거**해야 한다.

---

## 🏆 1. GC가 "살아 있는 객체"를 찾는 법 → 루트 노드 열거(Root Node Enumeration)
### **👀 What?**
GC는 **힙(Heap)에 있는 모든 객체를 뒤지는 대신**, "대장 루트노드(GC Root)"를 기준으로 탐색을 시작함.

### **🔥 GC Root의 종류**
1. **스택(Stack)의 지역 변수** (현재 실행 중인 메서드에서 사용 중인 객체)
2. **Static 변수** (`static` 키워드로 선언된 애들)
3. **실행 중인 Thread 객체** (이건 살아 있음)
4. **JNI에서 참조하는 네이티브 객체** (C/C++ 네이티브 코드에서 잡고 있는 애들)

✅ **GC는 여기서부터 살아 있는 객체를 따라가고, 끊긴 애들은 뒤진 걸로 간주하고 치움!**

---

## ⚡ 2. 문제: GC를 하려면 공장이 멈춘다 (STW, Stop-the-World)

GC가 뒤진 객체를 찾으려면 모든 스레드를 멈추고(STW) 조사해야 하는데, **이게 존나 비효율적임.**

✅ **해결책: "OOP Map"을 이용해 빠르게 탐색!**

---

## 🔥 3. OOP Map(Object Orderly Pointer Map)이란?
### **👀 What?**
GC가 스택을 조사할 때, **객체 참조가 어디에 있는지 미리 기록해둔 지도 같은 데이터 구조**.

### **🤔 Why?**
- **그냥 다 뒤지면? 존나 오래 걸림**
- **OOP Map을 활용하면? 필요한 곳만 빠르게 검사 가능**

### **🛠️ How? (OOP Map 최적화 원리)**
1. **JIT 컴파일 시, OOP Map을 생성**
2. **GC 실행 시, OOP Map을 참고해서 빠르게 루트 노드 탐색**

✅ **하지만, OOP Map을 너무 많이 만들면 메모리 과부하 발생!** → **이걸 해결하는 게 안전 지점, 안전 지역**


## OOP Map을 다 만들기 힘드니까 안전 지점(Safe Point)과 안전 지역(Safe Region) 등장!
### **👀 What?**
GC가 언제든지 모든 객체를 스캔할 수 없으니까, 특정한 "안전 지점(Safe Point)"에서만 스레드를 멈추고 OOP Map을 확인함.

### **🤔 Why?**
- **GC가 무작정 실행되면 실행 중인 코드가 메모리를 엉망으로 만듦.**
- **그래서 특정한 시점(메서드 호출, 반복문 끝, 예외 발생)에서만 GC가 스레드를 멈출 수 있도록 제한함.**

### **🛠️ How? (안전 지점 & 안전 지역 개념)**
1. **Safe Point (안전 지점)** → 공장을 돌리다가 특정 지점(메서드 호출, 반복문 끝, 예외 발생)에서만 멈춰서 GC 실행.
2. **Safe Region (안전 지역)** → 뒤진 건 아니지만, 어차피 자고 있거나 쉬고 있는 새끼들(예: I/O 대기, `sleep()` 상태)에서 GC를 실행해서 성능 최적화.
3. 

✅ **결론: GC가 모든 코드를 방해하지 않고, 효율적으로 실행될 수 있도록 안전한 타이밍을 정하는 거다!**

---

## 💣 4. 카드 테이블(Card Table) → GC 탐색 최적화
### **👀 What?**
힙을 작은 블록(Card)으로 나누고, **변경된 블록만 추적하는 구조**.

### **🤔 Why?**
- **힙 전체를 다 뒤지면 성능 개박살.**
- **변경된 블록(Dirty Bit)만 검사하면 탐색 속도 🚀 상승.**

### **🛠️ How? (카드 테이블 최적화 원리)**
1. **힙을 "카드(Card)" 단위(512B~1KB)로 나눔**
2. **객체가 수정되면 해당 카드의 상태를 Dirty(변경됨)으로 마킹**
3. **GC 실행 시, Dirty 표시된 카드만 검사!**

✅ **결과: 힙 전체를 뒤질 필요 없이, 변경된 부분만 검사하여 GC 속도가 🚀 미친 듯이 향상됨!**

---

## 🔥 5. 기억 집합(Remembered Set, RSet) → Old → Young 참조 최적화
### **👀 What?**
Old Generation에서 Young Generation을 **참조할 때, Old Gen 전체를 뒤지지 않도록 최적화하는 데이터 구조**.

### **🤔 Why?**
- Young GC 실행 시, **Old Generation에서 Young Generation을 참조하는 객체가 있을 수도 있음.**
- 그냥 무식하게 Old Generation 전체를 탐색하면 존나 비효율적.
- **그래서 "Old → Young 참조"만 따로 기록해두고, 필요할 때만 검사하면 됨.**

### **🛠️ How? (기억 집합 최적화 원리)**
1. **Old Generation에 있는 객체가 Young Generation을 참조할 때, 이를 기억 집합에 기록**
2. **GC 실행 시, 기억 집합을 참조하여 "Old → Young 참조"만 검사**
3. **Old Generation 전체를 뒤지는 개비효율적인 작업을 방지**

✅ **결과: Old Generation을 무식하게 스캔하는 걸 방지해서 GC 성능 🚀 초월 최적화!**

---

## 🧠 6. 올드가 영을 조지는 이유 (Old Gen → Young Gen 참조 발생 이유)
1. **꼰대(Old Gen)가 MZ(Young Gen)에게 일 시킴**
   - `static`으로 선언된 오래된 객체가 새로운 객체를 생성하고 관리함.
   ```java
   class Manager {  // Old Gen
       Employee employee;  // Young Gen
   }
   Manager m = new Manager(); // Old Generation에 들어감
   m.employee = new Employee(); // Young Generation 객체를 참조
   ```

2. **꼰대(Old Gen)가 새로운 프로젝트를 주고 관리함**
   - `ArrayList` 같은 자료구조를 Old Generation에서 관리하는데, 새로운 데이터는 Young Generation에서 생성됨.
   ```java
   class DatabaseConnection {  // Old Gen
       List<Query> queries = new ArrayList<>();  // Young Gen에 있는 데이터
   }
   ```

3. **MZ(Young Gen)가 꼰대(Old Gen)한테 도움을 요청함**
   - Young Generation 객체가 Old Generation 객체를 호출하여 참조가 생김.

✅ **결론: 올드가 영을 참조하는 건 피할 수 없는 구조적 특성이다!**

---

## 🚀 6. 쓰기 장벽(Write Barrier) → GC 최적화를 위한 핵심 기술
### **👀 What?**
쓰기 장벽(Write Barrier)은 **GC가 카드 테이블(Card Table)과 기억 집합(Remembered Set)을 자동으로 관리하도록 만드는 감시 시스템**이다.

### **🤔 Why?**
- **문제 1:** 카드 테이블은 **힙을 잘게 쪼개서 변경된 애만 체크**하는데, **이걸 실시간으로 검사하면 오버헤드가 심함**.
- **문제 2:** 기억 집합(Remembered Set)은 **Old Generation이 Young Generation을 참조할 때만 기록해야 함** → **실시간 추적 필요**.
- **✅ 해결책:** GC가 **객체 참조 변경이 일어날 때마다 자동으로 감지해서 카드 테이블 & 기억 집합을 업데이트하도록 만듦.**

### **🛠️ How? (바이트코드에서 실행되는 방식)**
1. **객체 참조가 변경될 때 실행됨.**
   ```java
   someOldGenObject.child = new YoungGenObject(); // Old Gen → Young Gen 참조 변경
   ```
2. **JVM이 바이트코드를 변환하여 감싸버림.**
   ```assembly
   CALL WriteBarrier_beforeWrite
   MOV someOldGenObject.child, new YoungGenObject
   CALL WriteBarrier_afterWrite
   ```
✅ **결론:** **객체 참조 변경이 일어나면 자동으로 카드 테이블과 기억 집합을 업데이트하도록 JVM이 개입하는 것!**

### **🔥 비유로 이해해보자**
1. **쓰기 장벽 없는 코드** = **"정신뒤진 도박중독자"** → 아무 데나 들이박고 난장판 만듦.
2. **쓰기 장벽 있는 코드** = **"도박 사이트 접속 시 니가 접속해있는 와이파이가 자동 감지해서 로그 남기는 시스템"** → **네가 어디 접속하든 관리자가 추적 가능! GC도 객체 참조가 변경될 때마다 자동으로 감지해서 관리 가능!**

✅ **결론:** **JVM이 객체 참조 변경을 "자동 감지"할 수 있도록 바이트코드에 Write Barrier를 삽입하는 거다!** 🚀

---

## ⚡ 7. 윌슨의 객체 사라짐 오류(1994)와 SATB(Snapshot-at-the-Beginning) 기법
### **👀 What?**
1994년 윌슨이 발견한 **GC의 치명적 버그**가 있음.  
GC가 **탐색하는 도중 객체의 상태가 바뀌면, 원래 살아 있어야 할 객체가 실수로 삭제되는 문제**가 발생할 수 있음.

### **🤔 Why? (이 오류가 왜 발생함?)**
GC가 **삼색 표시 기법(검은색, 회색, 흰색)으로 객체를 관리**하는데,  
아래 두 가지 조건이 동시에 만족되면 **GC가 살아 있는 객체를 지워버리는 현상 발생!**

1️⃣ **객체가 아직 사용 중인데 "회색(검사 중)" 상태로 변경됨.**
2️⃣ **GC가 검사하는 도중, 객체의 참조가 변경되어 "흰색(삭제 후보)"으로 바뀌어버림.**

🔥 **결과:**
- **객체는 여전히 살아 있는데도 불구하고 GC가 지워버림.**
- **즉, 사용 중인 데이터가 증발하는 심각한 문제 발생.**

---

### **🔥 비유: 온라인 문서 작업 중 데이터가 날아가는 상황**
1. **너가 온라인 문서를 편집 중인데, 문서를 자동 저장하는 시스템이 있음.**
2. **자동 저장 시스템(GC)이 네가 편집 중인 내용을 "확인 중(회색)"이라고 판단함.**
3. **근데 네가 갑자기 다른 섹션으로 넘어가거나 임시 저장한 뒤 창을 닫아버림.**
4. **자동 저장 시스템이 "어? 이거 필요 없는 데이터네?" 하고 지워버림.**
5. **다시 돌아와 보니 네가 쓰던 문서 내용이 통째로 날아가 있음.**

🔥 **즉, GC도 비슷한 방식으로 "검사 중이던 객체"가 참조가 끊기면, 살아 있어야 할 객체를 삭제하는 실수를 할 수 있음.**

---

### **🛠️ 해결책: SATB(Snapshot-at-the-Beginning) 기법**
✅ **이 문제를 해결하기 위해 등장한 것이 SATB (스냅샷 유지 기법)**
1. **GC가 탐색을 시작할 때, 현재 모든 객체 상태를 "스냅샷"으로 저장함.**
2. **탐색이 끝날 때까지 객체가 변경되더라도, "스냅샷에 있던 애들은 무조건 삭제하지 않음".**
3. **즉, "일단 탐색을 시작할 때 상태를 보장하고, 탐색하는 동안에는 안전하게 관리하자"는 개념.**

✅ **결과:**
- **GC가 탐색 중이더라도, 살아 있는 객체를 실수로 삭제하지 않게 됨.**
- **온라인 문서도 "임시 저장 상태"를 보장해서, 편집 중인 데이터가 날아가는 걸 방지하는 것과 같음.**

---

🔥 **결론:**
- **GC가 탐색하는 동안 객체 상태가 바뀌면, 살아 있는 객체를 실수로 삭제할 수도 있음.**
- **이걸 막기 위해 SATB(Snapshot-at-the-Beginning) 기법을 사용해서 탐색을 시작할 때 "스냅샷"을 찍고, 안전하게 GC를 진행함.**

✅ **이제 GC가 살아 있는 객체를 실수로 삭제하는 문제는 해결됨!** 🚀
# 🚀 JVM GC - 객체가 뒤졌는지 판단하는 기준

## **💀 1. 참조 카운팅(Reference Counting) - 병신 알고리즘**
### **👀 What?**
참조 카운팅은 **객체가 참조될 때마다 카운트를 증가시키고, 참조가 사라지면 감소시키는 방식**이다.  
카운트가 `0`이 되면 **"이 객체는 뒤졌다!"**라고 판단하고 메모리에서 해제함.

### **🤔 Why? (왜 병신이냐?)**
👉 **순환 참조(Reference Cycle) 문제 때문에 병신임.**
- 객체 `A`가 객체 `B`를 참조하고, `B`가 다시 `A`를 참조하는 경우
- **서로 참조하고 있어서 카운트가 0이 안 됨** → **이제 절대 못 지움! (Memory Leak 발생)**

```java
class A {
    B b;
}

class B {
    A a;
}

A a = new A();
B b = new B();
a.b = b;
b.a = a; // 둘이 서로 참조해서 절대 해제되지 않음!
```
🔥 **결론:**  
**순환 참조 문제 때문에 JVM에서 "이거 병신이네" 하고 버림.**  
✅ **JVM은 "도달 가능성 분석(Reachability Analysis)"을 씀.**

---

## **🔥 2. 도달 가능성 분석(Reachability Analysis) - 진짜 GC 판단법**
### **👀 What?**
도달 가능성 분석은 **"이 객체가 여전히 유효한 경로에서 접근 가능한가?"** 를 확인하는 방법.  
👉 **즉, "살아 있는 루트 노드(GC Root)에서 이 객체까지 도달할 수 있냐?"** 가 핵심이다.

### **🛠️ How? (어떻게 동작함?)**
1. **GC Root에서 탐색을 시작함.**
2. **연결된 객체들을 따라가면서 "살아 있는 애들"을 표시함.**
3. **도달할 수 없는 객체는 "뒤진 걸로 간주하고 제거(GC 수행)".**

✅ **결론:**
- **"살아 있는 애들"은 유지되고, "고아 객체(더 이상 도달할 수 없는 애들)"만 정리됨.**
- **이제 참조 카운팅처럼 병신같이 순환 참조 문제를 고민할 필요 없음!**

---

## **🔥 3. GC Root (도달 가능성 분석의 출발점)**
GC는 **아래 4가지 객체를 GC Root로 간주하고 여기서부터 탐색을 시작함.**

| **GC Root 대상** | **설명** |
|-----------------|---------|
| **스택(Stack) 변수** | 현재 실행 중인 메서드의 지역 변수들 |
| **메서드 영역의 static 변수** | 클래스 레벨에서 관리되는 정적(static) 변수들 |
| **메서드 영역의 constant pool** | 런타임 상수 풀에 저장된 참조형 데이터 |
| **JNI 네이티브 참조** | C/C++ 같은 네이티브 코드에서 사용 중인 객체 |

✅ **이 GC Root에서 시작해서 객체를 따라가며 탐색, 도달하지 못하는 애들은 뒤진 걸로 간주!**

---

# 🚀 JVM GC - GC Root와 참조 상태 4가지

## **🔥 1. GC Root가 되는 애들의 논리적인 조건**
**GC가 객체를 회수하려면 "살아 있는 애"를 먼저 구별해야 한다.**  
**그럼 GC Root로 인정받는 새끼들은 누구냐?**  
**바로 "프로그램이 언제든 접근할 수 있는 애들"이다!**

### **📌 GC Root가 되는 기준 4가지**
| **GC Root 대상** | **설명** | **논리적 이유 (왜 GC Root인가?)** |
|-----------------|---------|--------------------------------|
| **스택(Stack) 변수** | 현재 실행 중인 메서드의 지역 변수들 | **스택은 함수 실행 중에 무조건 접근 가능!** GC가 스택을 없애면 프로그램이 바로 터짐. |
| **메서드 영역의 static 변수** | 클래스 레벨에서 관리되는 정적(static) 변수들 | **Static 변수는 JVM이 실행되는 한 계속 살아 있음.** 전역 변수 개념이라 접근이 언제든 가능. |
| **메서드 영역의 constant pool** | 런타임 상수 풀에 저장된 참조형 데이터 | **클래스가 로딩된 순간부터 사용 가능!** 프로그램이 참조할 가능성이 높기 때문에 GC Root가 됨. |
| **JNI 네이티브 참조** | C/C++ 같은 네이티브 코드에서 사용 중인 객체 | **JVM 밖에서도 사용 중이므로, GC가 멋대로 해제하면 안 됨.** |

🔥 **결론:** **GC Root란 "무조건 접근 가능해서 없애면 안 되는 것들"이다!**  
💥 **즉, "이 새끼들이 GC 대상이 되면 프로그램이 터진다" 수준의 애들이 GC Root임!**

---

## **🔥 2. 객체 참조 상태 4가지 - 왜 이렇게 나눠진 거냐?**
JVM이 객체를 관리할 때, **참조 상태에 따라 GC 전략이 달라짐.**  
👉 **즉, "이 객체가 얼마나 살아남아야 하는지"에 따라 다르게 처리해야 함!**

### **📌 객체 참조 상태 4가지**
| **참조 종류** | **설명** | **논리적 이유 (왜 이 상태가 필요한가?)** |
|--------------|---------|--------------------------------|
| **강한 참조 (Strong Reference)** | 일반적인 참조 (`new`로 생성한 객체) | **"이거 진짜 중요하니까 절대 삭제하면 안 돼!"** GC가 절대 건들면 안 되는 객체. |
| **약한 참조 (Weak Reference)** | `WeakReference<T>` 사용 | **"얘는 그냥 캐싱용이니까 GC가 필요하면 바로 삭제해도 됨."** |
| **소프트 참조 (Soft Reference)** | `SoftReference<T>` 사용 | **"메모리가 부족할 때만 삭제해라."** 즉, 메모리 절약하면서도 필요하면 유지할 수 있음. |
| **유령 참조 (Phantom Reference)** | `PhantomReference<T>` 사용 | **"이미 삭제된 애지만 후처리를 해야 한다."** 즉, 삭제 후 정리 작업이 필요한 경우를 위해 존재. |

---

## **🔥 3. 왜 이런 참조 상태가 필요한가?**
### **🔥 현실적인 문제들**
1️⃣ **강한 참조만 있으면?**
- **메모리가 터짐.** (GC가 아무것도 못 치우니까)
- **캐시 같은 최적화가 불가능함.**

2️⃣ **약한 참조만 있으면?**
- **GC가 아무 때나 객체를 치워버려서 안정성이 없음.**

3️⃣ **소프트 참조가 없으면?**
- **메모리 부족할 때만 제거하는 기능이 없어서 메모리 관리가 어려움.**

4️⃣ **유령 참조가 없으면?**
- **객체가 삭제된 후에도 반드시 정리해야 할 작업이 있을 때 처리가 불가능함.**

🔥 **결론:**
- **GC가 너무 보수적이면 메모리가 터지고, 너무 공격적이면 데이터가 날아감.**
- **이걸 조절하려고 "참조 4형제"가 만들어진 거다!**

---

## **💥 최종 결론 - GC는 이렇게 객체를 판단한다!**
1. **GC Root는 "없애면 프로그램이 터지는 애들"이다.**
2. **도달 가능성 분석을 통해 "살아 있는 객체"를 찾는다.**
3. **객체마다 참조 상태를 구분해서 GC 전략을 다르게 적용한다.**
4. **이 모든 게 결국 "최적의 메모리 관리"를 위해 필요한 것들이다!**

🔥 **이제 GC가 객체를 삭제하는 기준이 명확해졌다!** 🚀


# JVM에서 참조 카운팅 알고리즘을 사용하지 않는 이유

---

## 1. 참조 카운팅 알고리즘이란?
**참조 카운팅(Reference Counting)**은 각 객체가 참조되고 있는 **참조 수(Reference Count)**를 유지하여 메모리를 관리하는 방식입니다.

### 동작 방식:
1. 객체가 생성되면 참조 카운트는 1로 초기화됩니다.
2. 객체를 참조하는 변수가 늘어나면 카운트가 증가합니다.
3. 참조가 제거되면 카운트가 감소합니다.
4. 참조 카운트가 0이 되면, 해당 객체는 더 이상 사용되지 않는 것으로 판단되어 메모리에서 제거됩니다.

---

## 2. 참조 카운팅의 장점
- **간단한 구현**: 참조 수만 관리하면 되므로 구현이 비교적 쉽습니다.
- **실시간 메모리 회수**: 객체의 참조 카운트가 0이 되는 즉시 메모리를 회수할 수 있습니다.
- **예측 가능성**: 객체가 언제 정리될지 명확하게 알 수 있습니다.

---

## 3. JVM이 참조 카운팅을 사용하지 않는 이유

### 1) 순환 참조 문제
참조 카운팅의 가장 큰 단점은 **순환 참조(Circular Reference)** 문제입니다.

#### 순환 참조란?
- 두 객체가 서로를 참조하는 경우, 참조 카운트가 0이 되지 않아 메모리 누수가 발생할 수 있습니다.

#### 예제 코드:
```java
class Node {
    Node next;
}

public class ReferenceCountingExample {
    public static void main(String[] args) {
        Node node1 = new Node();
        Node node2 = new Node();
        
        // 서로를 참조
        node1.next = node2;
        node2.next = node1;

        // 모든 참조 제거
        node1 = null;
        node2 = null;

        // 참조 카운트는 0이 되지 않음 -> 메모리 누수 발생
    }
}
```

위 코드에서 node1과 node2는 서로를 참조하기 때문에 참조 카운트는 0이 되지 않습니다.
이러한 순환 참조는 JVM이 메모리를 회수하지 못하게 만들어 메모리 누수를 초래합니다.


### 2) 현대적인 GC 기술과의 비교
- 참조 카운팅은 메모리를 관리하기 위한 단순한 방법이지만, 현대 JVM에서는 더 강력한 추적 기반 가비지 컬렉션(Tracing GC) 방식을 사용합니다.
- 추적 기반 GC는 **객체의 접근 가능성(Reachability)**을 기준으로 메모리를 관리하여 순환 참조 문제를 해결합니다.

#### 예: 추적 기반 GC의 장점
1. 루트에서 시작하는 객체 그래프 탐색
- JVM은 **GC 루트(GC Root)** 에서 시작하여 접근 가능한 객체만 탐색합니다.
- 순환 참조가 있더라도, 루트에서 도달할 수 없는 객체는 정리됩니다.

2. 효율적인 메모리 관리
- 참조 카운팅 방식과 달리, JVM의 GC는 객체의 생명 주기를 보다 효율적으로 관리할 수 있습니다.


## 4. 실제 JVM이 사용하는 접근 방식
JVM은 참조 카운팅 대신 Mark-and-Sweep, Generational GC, CMS, G1 GC, ZGC와 같은 다양한 추적 기반 가비지 컬렉션 알고리즘을 사용합니다.

### JVM 가비지 컬렉터 특징:
1. GC Root에서 시작
루트 객체에서 시작하여 모든 접근 가능한 객체를 탐색합니다.
2. 순환 참조 해결
순환 참조가 있더라도 GC 루트에서 도달할 수 없는 객체는 정리됩니다.
3. 성능 최적화
객체의 생명 주기에 따라 메모리를 효율적으로 정리합니다.

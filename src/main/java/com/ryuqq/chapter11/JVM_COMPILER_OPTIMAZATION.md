# JVM 컴파일러와 최적화 기술

## 1. 자바 컴파일 과정: `.java` → `.class` 변환
### 🔹 자바 컴파일러(`javac`)의 3단계 과정
✅ **1단계: 구문 분석(Parsing) 및 AST(Abstract Syntax Tree) 생성**
- 자바 소스 코드를 읽고, 문법적으로 올바른지 확인하며 AST(추상 구문 트리) 생성
- CheckStyle 같은 정적 분석 도구가 실행될 수 있음

✅ **2단계: 중간 표현(IR, Intermediate Representation) 변환 및 분석**
- AST를 바탕으로 중간 표현(IR)으로 변환됨
- 타입 검증, 변수 범위 확인, 최적화 수행

✅ **3단계: 바이트코드 생성**
- `.class` 파일(바이트코드) 생성
- 바이트코드 최적화 적용 가능

---

## 2. JIT(Just-In-Time) 컴파일러
### 🔹 JIT 컴파일러 개념
- ✅ **실행 중(런타임) 특정 메서드가 "핫스팟(Hot Method)"인지 감지한 후, 네이티브 코드로 변환하여 성능을 최적화하는 기술.**
- ✅ **JVM 내부에서 백그라운드 스레드가 핫 메서드를 판단하며 최적화를 수행함.**

### 🔹 JIT 컴파일러의 최적화 기법
#### ✅ 1. 메서드 인라이닝(Method Inlining)
🔥 **자주 호출되는 메서드의 코드를 호출하는 곳에 직접 삽입하여 `invoke` 비용을 제거하는 방식**
```java
// 원본 코드
int calculate(int x) {
    return x * 2;
}

int result = calculate(5);
```
✅ **JIT 최적화 후:**
```java
// 메서드가 인라이닝됨
int result = 5 * 2;
```
✅ **이렇게 하면 메서드 호출 비용을 줄이고 실행 속도를 높일 수 있음.**

#### ✅ 2. 탈출 분석(Escape Analysis)
🔥 **객체가 특정 메서드 내부에서만 사용되고, 다른 스레드에서 접근하지 않는 것이 확실하면, 힙 대신 스택 프레임에 객체를 할당하여 성능을 최적화.**
```java
class Sample {
    private int value;
    public Sample(int v) { this.value = v; }
}

void process() {
    Sample obj = new Sample(10); // JIT이 스택에 할당할 가능성 있음
}
```
✅ **JIT 최적화 후:**
- `Sample obj`가 메서드 내부에서만 사용되므로, JVM이 스택에 할당.
- **GC(가비지 컬렉션) 부담이 줄어들고, 객체 해제가 자동으로 이루어짐.**

#### ✅ 3. 루프 최적화(Loop Optimization)
🔥 **자주 실행되는 루프를 더 효율적으로 실행하기 위해 최적화 적용**
- ✅ **루프 언롤링(Loop Unrolling): 반복 횟수가 적으면 루프 자체를 제거하고 바디를 여러 번 복제**
- ✅ **루프 전위 코드 이동(Loop Invariant Code Motion): 루프 내부에서 변하지 않는 코드를 루프 바깥으로 이동**

#### ✅ 4. 탈출 분석(Escape Analysis)과 스칼라 교체(Scalar Replacement)
🔥 **객체의 필드를 개별 변수로 변환하여 객체 생성을 줄이고 성능을 향상**
```java
class Point {
    int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
}

void move() {
    Point p = new Point(1, 2); // 객체 생성
    int newX = p.x + 10;
    int newY = p.y + 10;
}
```
✅ **JIT 최적화 후:**
```java
// 객체를 직접 사용하지 않고 변수로 변환
int newX = 1 + 10;
int newY = 2 + 10;
```
✅ **즉, 불필요한 객체 생성을 줄여 성능을 향상시킴.**

---

## 3. AOT(Ahead-Of-Time) 컴파일러
### 🔹 AOT 컴파일러 개념
- ✅ **JVM이 실행되기 전에 바이트코드를 네이티브 코드로 변환하여, JIT 없이 실행 속도를 향상시키는 방식.**
- ✅ **대표적인 AOT 컴파일러: GraalVM `native-image`, Android ART(Android Runtime).**

### 🔹 AOT의 장점과 단점
✅ **장점**
- 프로그램 실행 속도가 빠름 (이미 네이티브 코드로 변환됨)
- JIT 컴파일 비용이 없음
- 실행 환경 변화가 적은 경우 최적화된 성능 제공
  ✅ **단점**
- 실행 중 최적화(JIT) 불가능
- 코드 크기가 증가할 가능성이 있음

---

## 4. JIT vs AOT 비교
|  | **JIT(Just-In-Time) 컴파일러** | **AOT(Ahead-Of-Time) 컴파일러** |
|----------------|------------------------------|------------------------------|
| **컴파일 시점** | 프로그램 실행 중 (런타임) | 프로그램 실행 전에 (빌드 타임) |
| **최적화 방식** | 실행 중 최적화 (Hotspot) | 미리 컴파일된 코드 실행 |
| **성능** | 초기 실행 속도는 느리지만, 장기적으로 최적화됨 | 초기 실행 속도가 빠름 |
| **유연성** | 실행 환경에 따라 최적화 가능 | 실행 환경 변화에 대응 어려움 |
| **사용 사례** | JVM의 HotSpot JIT, Graal JIT | GraalVM AOT, Android ART |

🔥 **즉, JIT은 "실행 중 최적화"를 통해 장기적인 성능 향상을 목표로 하고, AOT는 "즉시 실행 가능"한 빠른 시작 성능을 목표로 한다.** 🚀🔥

---

## 5. 최종 정리
- ✅ **자바 컴파일러(`javac`)는 3단계(Parsing → IR 변환 → 바이트코드 생성) 과정을 거쳐 `.java` → `.class` 변환을 수행함.**
- ✅ **JIT 컴파일러는 실행 중 "핫 메서드"를 감지하여 네이티브 코드로 변환하는 방식.**
- ✅ **JIT의 주요 최적화 기법: 메서드 인라이닝, 탈출 분석, 루프 최적화, 스칼라 교체 등.**
- ✅ **AOT 컴파일러는 실행 전에 네이티브 코드로 변환하여 JIT 없이 빠르게 실행할 수 있도록 함.**
- ✅ **JIT은 실행 시간이 지날수록 최적화되지만, AOT는 실행 초기 속도가 빠르고 JIT 컴파일 비용이 없다.**
- ✅ **자바의 최신 런타임 환경에서는 JIT과 AOT를 혼합하여 최적화하는 경우도 많다(GraalVM 등).**

🔥 **이제 JIT과 AOT에 대해 확실히 이해했냐? 더 궁금한 게 있으면 바로 조지자!** 🚀🔥


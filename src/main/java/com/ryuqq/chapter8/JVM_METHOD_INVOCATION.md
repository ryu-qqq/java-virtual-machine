# JVM 메서드 호출과 해석

## 1. 메서드 호출 방식
JVM에서 메서드를 호출할 때 **invoke** 명령어를 사용하며, 호출 방식에 따라 다르게 동작합니다.

### 🔹 메서드 호출 명령어 종류
1. **`invokestatic`** – 정적(static) 메서드 호출
2. **`invokevirtual`** – 인스턴스 메서드 호출 (동적 디스패치 적용)
3. **`invokeinterface`** – 인터페이스 메서드 호출
4. **`invokespecial`** – 생성자, private, super 메서드 호출

## 2. 메서드 해석 과정과 상수 풀
### 🔥 클래스 파일 상수 풀(Constant Pool)과 런타임 상수 풀(Runtime Constant Pool)
- **클래스 파일 내부**에는 **Constant Pool(상수 풀)**이 존재하여, 문자열 리터럴, 메서드 참조, 클래스 참조 정보가 저장됨.
- JVM이 클래스를 로드하면서 **상수 풀을 메서드 영역(Method Area)의 런타임 상수 풀로 변환하여 저장**.

### 📌 메서드 해석 과정
1. **컴파일 시점** – `.class` 파일 내부의 **Constant Pool 생성**
2. **클래스 로딩 시점** – JVM이 상수 풀을 **메서드 영역의 런타임 상수 풀로 변환하여 저장**
3. **메서드 참조 확인** – 런타임 상수 풀에서 메서드의 레퍼런스를 찾음
4. **실제 메서드 찾기**
    - 정적 메서드 (`invokestatic`) → **바로 참조 가능**
    - 가상 메서드 (`invokevirtual`) → **동적 디스패치 적용 후 실제 메서드 결정**
5. **스택 프레임 생성** – 호출된 메서드를 실행하기 위한 프레임 생성
6. **PC 레지스터 업데이트** – 새 메서드의 첫 바이트코드로 이동 후 실행

## 3. 메서드 호출 예제 및 바이트코드 분석
### 📌 예제 코드
```java
public class Example {
    public void sayHello() {
        System.out.println("Hello, JVM!");
    }
}
```

### 📌 바이트코드 확인 (`javap -v Example.class` 실행 결과)
```
0: aload_0
1: invokevirtual  #2  // Method Example.sayHello:()V
```
- `invokevirtual #2` → 런타임 상수 풀에서 `Example.sayHello()`를 참조하여 실행

## 4. 런타임 상수 풀의 역할
- 메서드 참조, 클래스 정보, 필드 정보 등을 포함하여 JVM이 실행 중에 필요한 정보를 빠르게 조회할 수 있도록 함.
- **메서드 호출 시 런타임 상수 풀을 참조하여 해당 메서드의 실제 메모리 주소를 찾고 실행**.

## 🎯 JVM 메서드 호출 요약
✅ **메서드 호출은 `invoke*` 명령어를 통해 실행됨**
✅ **클래스 파일의 Constant Pool은 클래스 로딩 후 런타임 상수 풀로 변환됨**
✅ **JVM은 런타임 상수 풀을 참조하여 메서드의 실제 메모리 주소를 찾아 실행**
✅ **정적 메서드는 바로 참조 가능, 가상 메서드는 동적 디스패치 후 결정됨**

---

